!function(e){var n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s=0)}([function(e,n,r){!function e(n,r,t){function o(c,s){if(!r[c]){if(!n[c]){if(i)return i(c,!0);var u=new Error("Cannot find module '"+c+"'");throw u.code="MODULE_NOT_FOUND",u}var a=r[c]={exports:{}};n[c][0].call(a.exports,(function(e){return o(n[c][1][e]||e)}),a,a.exports,e,n,r,t)}return r[c].exports}for(var i=!1,c=0;c<t.length;c++)o(t[c]);return o}({1:[function(e,n,r){let t=e("@polkadot/extension-dapp");window.polkadot_extension_dapp=t},{"@polkadot/extension-dapp":4}],2:[function(e,n,r){n.exports=function(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}},{}],3:[function(e,n,r){n.exports=function(e){return e&&e.__esModule?e:{default:e}}},{}],4:[function(e,n,r){"use strict";var t=e("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(r,"__esModule",{value:!0}),r.web3Enable=function(e){return r.web3EnablePromise=f=(0,i.documentReadyPromise)(()=>Promise.all(Object.entries(u.injectedWeb3).map(([n,{enable:r,version:t}])=>Promise.all([Promise.resolve({name:n,version:t}),r(e).catch(e=>{console.error(`Error initializing ${n}: ${e.message}`)})]))).then(e=>e.filter(([,e])=>!!e).map(([e,n])=>{n&&!n.accounts.subscribe&&(n.accounts.subscribe=e=>(n.accounts.get().then(e).catch(console.error),()=>{}));return s(s({},e),n)})).catch(()=>[]).then(e=>{const n=e.map(({name:e,version:n})=>`${e}/${n}`);return r.isWeb3Injected=b=a(),console.log(`web3Enable: Enabled ${e.length} extension${1!==e.length?"s":""}: ${n.join(", ")}`),e})),f},r.web3Accounts=p,r.web3AccountsSubscribe=async function(e){if(!f)return l("web3AccountsSubscribe");const n={},r=(await f).map(({accounts:{subscribe:r},name:t})=>r(r=>{n[t]=r,e(Object.entries(n).reduce((e,[n,r])=>(e.push(...d(n,r)),e),[]))}));return()=>{r.forEach(e=>{e()})}},r.web3FromSource=m,r.web3FromAddress=async function(e){if(!f)return l("web3FromAddress");const n=await p(),r=e&&n.find(n=>n.address===e);if(!r)throw new Error("web3FromAddress: Unable to find injected "+e);return m(r.meta.source)},r.web3ListRpcProviders=async function(e){const{provider:n}=await m(e);if(!n)return console.warn(`Extension ${e} does not expose any provider`),null;return n.listProviders()},r.web3UseRpcProvider=async function(e,n){const{provider:r}=await m(e);if(!r)throw new Error(`Extension ${e} does not expose any provider`);return{meta:await r.startProvider(n),provider:r}},r.web3EnablePromise=r.isWeb3Injected=void 0;var o=t(e("@babel/runtime/helpers/defineProperty")),i=e("./util");function c(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function s(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?c(Object(r),!0).forEach((function(n){(0,o.default)(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):c(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}const u=window;function a(){return 0!==Object.keys(u.injectedWeb3).length}function l(e){throw new Error(`${e}: web3Enable(originName) needs to be called before ${e}`)}function d(e,n){return n.map(({address:n,genesisHash:r,name:t})=>({address:n,meta:{genesisHash:r,name:t,source:e}}))}u.injectedWeb3=u.injectedWeb3||{};let b=a();r.isWeb3Injected=b;let f=null;async function p(){if(!f)return l("web3Accounts");const e=[],n=await f;(await Promise.all(n.map(async({accounts:e,name:n})=>{try{return d(n,await e.get())}catch(e){return[]}}))).forEach(n=>{e.push(...n)});const r=e.map(({address:e})=>e);return console.log(`web3Accounts: Found ${e.length} address${1!==e.length?"es":""}: ${r.join(", ")}`),e}async function m(e){if(!f)return l("web3FromSource");const n=await f,r=e&&n.find(({name:n})=>n===e);if(!r)throw new Error("web3FromSource: Unable to find an injected "+e);return r}r.web3EnablePromise=f},{"./util":5,"@babel/runtime/helpers/defineProperty":2,"@babel/runtime/helpers/interopRequireDefault":3}],5:[function(e,n,r){"use strict";Object.defineProperty(r,"__esModule",{value:!0}),r.documentReadyPromise=function(e){return new Promise(n=>{["complete","interactive"].includes(document.readyState)?n(e()):window.addEventListener("load",()=>{n(e())})})}},{}]},{},[1])}]);